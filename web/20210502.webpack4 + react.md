# webpack4从0到编译打包React+Typescript
## 1.webpack4配置babel解析ES6  
    
1.安装webpack依赖
> npm i webpack@4 webpack-cli -D
   
2.安装babel解析js的依赖  
> npm i @babel/core @babel/preset-env babel-loader  -D 

3.安装完babel后需要添加  ``.babelrc``  的文件
```js
//  /.babelrc
{
    "presets": [
        "@babel/preset-env"
    ]
}
```

4.编写webpack配置

```js
//  /webpack.config.js
const path = require('path')
/**
 *  @type {import('webpack').Configuration}
 */
module.exports = {
    entry: {
        main: './src/index.js'
    },
    output:{
        path: path.resolve(__dirname, './dist'),
        filename: '[name]-[hash].js'
    },
    module:{
        rules: [
            {
                test: /.js$/,
                use:[
                    {
                        loader: 'babel-loader',
                    },
                ]
            }
        ]
    }
}
```
5.使用webpack打包当前代码  
方式1: 
```bash
# webapck的可执行文件就在这个目录下面, 执行下面代码, webpack会找到当前目录下的webpack.config.js文件, 如果没有则使用webpack的默认配置
./node_modules/.bin/webpack 
# npm提供了npx的方式来执行./node_modules/.bin目录下的可执行文件, 下面命令小效果同上
npx webpack
```  



方式2:  

全局安装webpack@4 webpack-cli
> webpack  

然后执行webpack, 同样webpack会找到当前目录下的webpack.config.js,如果没有提供则使用webpack的默认配置   
  

方式3: 
在package.json中的script中添加执行命令
```js
{
  "scripts": {
    "test": "webpack"
  },
}
```  

`方式1使用的是安装到本地node_modules/.bin 目录下的webpack, webpack-cli的可执行文件, 而方式2使用的是安装到全局的webpack, webpack-cli, 使用时要注意webpack版本的差异, 方式3先查找本地然后查找全局`


## 2.webpack4配置babel-react解析react
1.安装依赖
首先需要安装react的相关联依赖  
> npm i react react-dom 
```js
//   /src/index.js
import React from 'react'
import ReactDom from 'react-dom'
class Index extends React.Component {
    state={
        name: "哈哈"
    }
    render(){
        return <div>{this.state.name}</div>
    }
}
ReactDom.render(
    <Index></Index>,
    document.getElementById('app')
)
```
2.webpack编译jsx语法
> npm i @babel/preset-react -D
```js
//  /.babelrc
{
    "presets": [
        "@babel/preset-env",
        "@babel/preset-react"
    ]
}
```
3.安装html-webpack-plugin自动将打包后的bundle插入到html文件中
```js
//  /webpack.config.js
const path = require('path')
const HtmlWebpackPlugin  = require('html-webpack-plugin')
/**
 *  @type {import('webpack').Configuration}
 */
module.exports = {
    entry: {
        index: './src/index.js',
        helloworld: './src/helloworld.js'
    },
    output:{
        path: path.resolve(__dirname, './dist'),
        filename: '[name]-[hash].js'
    },
    module:{
        rules: [
            {
                test: /.js$/,
                use:[
                    {
                        loader: 'babel-loader',
                    },
                ]
            }
        ]
    },
    plugins: [
        new HtmlWebpackPlugin({
            template: './public/index.html'
        }),
    ]
}
```
```html  
<!-- /public/index.html -->
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <div id="app"></div>
</body>
</html>
```

## 3.Webpack4配置sass-loader解析scss

1.安装依赖

> npm i style-loader css-loader sass-loader@10 node-sass -D  

`sass-loader`是用来将sass文件解析成css模块, `node-sass`就是sass的核心模块, `sass-loader`需要借助sass核心模块来解析.

`css-loader`是把css解析成webpack打包所需要的模块形式, webpack本身只支持js json文件的编译, css-loader是专门处理css文件模块的打包编译的

`style-loader`是把打包编译好的css模块用style标签插入到head中

`sass-loder在v11.0.0的Releases Note中表示只支持webpack5, less-loader在v8.0.0的Realeases Note中表示支持webpack5, 在使用webpack时, 选择更低版本, loader的执行顺序是从数组末尾到数组开头的顺序来执行的, 从sass-loader => css-loader => style-loader.`

2.修改webpack.config.js
```js
// /webpack.config.js
const path = require('path')
const HtmlWebpackPlugin  = require('html-webpack-plugin')
const {CleanWebpackPlugin} = require('clean-webpack-plugin')
/**
 *  @type {import('webpack').Configuration}
 */
module.exports = {
    entry: {
        index: './src/index.js',
        helloworld: './src/helloworld.js'
    },
    output:{
        path: path.resolve(__dirname, './dist'),
        filename: '[name]-[hash].js'
    },
    module:{
        rules: [
            {
                test: /.js$/,
                use:[
                    {
                        loader: 'babel-loader',
                    },
                ]
            },
            {
                test: /.(sc|sa|c)ss$/,
                use:[ 'style-loader','css-loader','sass-loader']
            }
        ]
    },
    plugins: [
        new CleanWebpackPlugin(),
        new HtmlWebpackPlugin({
            template: './public/index.html'
        }),
    ]
}
```

## 4.Webpack4打包编译字体和图片文件
`第4章webapck总览`
```js
// /webpack.config.js
const path = require('path')
const HtmlWebpackPlugin  = require('html-webpack-plugin')
const {CleanWebpackPlugin} = require('clean-webpack-plugin')
/**
 *  @type {import('webpack').Configuration}
 */
module.exports = {
    entry: {
        index: './src/index.js',
        helloworld: './src/helloworld.js'
    },
    output:{
        path: path.resolve(__dirname, './dist'),
        filename: '[name]-[hash].js'
    },
    module:{
        rules: [
            {
                test: /.js$/,
                use:['babel-loader']
            },
            {
                test: /.(sc|sa|c)ss$/,
                use:[ 'style-loader','css-loader','sass-loader']
            },
            {
                test: /.(woff|woff2|eot|ttf|otf)$/,
                use: ['file-loader']
            },
            {
                test: /.(png|jpg|svg|jpeg)$/,
                use: [
                    {
                        loader: 'url-loader',
                        options: {
                            limit: 1024 * 4, // 4kb以下就压缩成base64格式
                        }
                    }
                ]
            },
            {
                test:/\.html/,
                use: 'html-loader',
            }
        ]
    },
    plugins: [
        new CleanWebpackPlugin(),
        new HtmlWebpackPlugin({
            template: './public/index.html'
        }),
    ]
}
```
1.安装依赖
> npm i file-loader url-loader -D
`file-loader` 和 `url-loader` 功能基本一样, `url-loader`在`file-loader`的功能上提供了可以将小图片打包成base64的能力  

2.修改webpack配置和scss文件
```js
    module:{
        rules: [
            //...
            {
                test: /.(woff|woff2|eot|ttf|otf)$/,
                use: ['file-loader']
            },
            {
                test: /.(png|jpg|svg|jpeg)$/,
                use: [
                    {
                        loader: 'url-loader',
                        options: {
                            limit: 1024 * 4, // 4kb以下就压缩成base64格式
                        }
                    }
                ]
            },
        ]
    },
    plugins: [
        new CleanWebpackPlugin(),
        new HtmlWebpackPlugin({
            template: './public/index.html'
        }),
    ]
```

```scss
// /src/index.scss
@font-face
{
font-family: FiraCode;
src: url('./fonts/FiraCode-Bold.ttf');
font-weight: bold;
}
@font-face
{
font-family: FiraCode;
src: url('./fonts/FiraCode-Light.ttf')
}
#app{
    font-size: 20px;
    font-family: FiraCode;
    color: red;
}
body{
    background-image: url('./img/img.jpg');
}
```

3.打包html中引入的img图片
```js
{
    //..
    module:{
        rules: [
            //.,,
            {
                test: /.(woff|woff2|eot|ttf|otf)$/,
                use: ['file-loader']
            },
            {
                test: /.(png|jpg|svg|jpeg)$/,
                use: [
                    {
                        loader: 'url-loader',
                        options: {
                            limit: 1024 * 4, // 4kb以下就压缩成base64格式
                            // esModule: false, 
                        }
                    }
                ]
            },
            {
                test:/\.html/,
                use: 'html-loader', // 如果打包出现问题, 则在url-loader的options中添加esModule: false
            }
        ]
    }
    //..
}
```


## 5.Webpack-dev-server开启热更新
1.安装依赖
> npm i webpack-dev-server -D  
```js
// /webpack.config.js
const path = require('path')
const webpack = require('webpack')
const HtmlWebpackPlugin = require('html-webpack-plugin')
const { CleanWebpackPlugin } = require('clean-webpack-plugin')
/**
 *  @type {import('webpack').Configuration}
 */
module.exports = {
    watch: false, // 这里同webpack --watch , 监听文件的改动并且自动编译, 不过可以选择更好的dev-server和热更新的方式
    watchOptions: {
        // 类似函数节流防抖, 300ms内无文件改动, webapck才重新编译
        aggregateTimeout: 300,
        ignored: /node_modules/, // 排除node_modules目录
        poll: 10, // 每秒轮训文件是否改动的次数
    },
    entry: {
        index: './src/index.js',
        helloworld: './src/helloworld.js'
    },
    output: {
        path: path.resolve(__dirname, './dist'),
        filename: '[name]-[hash].js'
    },
    module: {
        rules: [
            {
                test: /.js$/,
                use: ['babel-loader']
            },
            {
                test: /.(sc|sa|c)ss$/,
                use: ['style-loader', 'css-loader', 'sass-loader']
            },
            {
                test: /.(woff|woff2|eot|ttf|otf)$/,
                use: ['file-loader']
            },
            {
                test: /.(png|jpg|svg|jpeg)$/,
                use: [
                    {
                        loader: 'url-loader',
                        options: {
                            limit: 1024 * 5, // 4kb以下就压缩成base64格式
                        }
                    }
                ]
            }
        ]
    },
    plugins: [
        new webpack.HotModuleReplacementPlugin(),
        new CleanWebpackPlugin(), // dev-server生成的打包文件在内存里, 此时项目并没有dist目录可以清理, 所以并没有什么影响
        // 即使在内存中也要利用HtmlWebpackPlugin插件来生成一个html文件,不然dev-server生成在内存的bundle文件仅仅只是生成了,并没有html文件可以提供
        new HtmlWebpackPlugin({
            template: './public/index.html'
        }),
    ],
    devServer: {
        hot: true,
        port: 9000,
    },
}
```
2. dev-server的执行方式
在package.json中添加一下命令
```js
{
    "scripts": {
        "dev": "cross-env NODE_ENV=production webpack server --open"
    }
}

```  
开启webpack-dev-server  
> npm run dev


## 6.Webpack中的hash, chunkhash, contenthash  

1.hash介绍  
- `webpack每一个入口文件都有可能引入其他的模块, 其它的模块又能引入其他的模块, 形成递归, 从而每一个入口都可以看成是一棵树的根节点, 从引入的模块开始递归出一整棵树.`   
- `一个入口形成的一棵树就是一个chunk,  chunkhash指的就是这棵树的所有文件的hash指纹, 树中只要有一个模块有修改, chunkhash就会改变.`     
- `webpack可以有一个入口, 也可以有多个入口, 多个入口就有多棵树, 多棵树的所有文件的hash指纹也就是webpack项目的hash.`    
- `而每个入口形成的每棵树中的每一个文件的hash指纹就是 contenthash.`  
- `三个hash的粒度不同 hash > chunkhash > contenthash`  

2.根据不同粒度的hash来给webpack的输出文件指定hash指纹
- `1.每一个js入口文件都应该只根据入口这棵树来生成hash, 所以入口文件输出时的文件名应该使用chunkhash`
- `2.css文件作为入口文件这棵树中的一环, 应该只因为自己内容改动而改变hash值, 没必要因为树中其它文件改动导致的chunkhash改动来改变自己的hash, 所以它的粒度为contenthash`

3.file-loader中的hash等占位符
- [ext]          资源后缀名
- [name]         文件名称
- [path]         文件相对路径
- [folder]       文件所在的文件夹
- [contenthash]  文件的内容hash,默认是md5生成
- [hash]         文件的内容hash,默认是md5生成
- [emoji]        一个随机的指代文件内容的emoji    

  一般图片放在/src/img下, 字体放在 /src/fonts下, 如果css,字体这些文件打包的时候输出的名称中使用path, 则会在dist目录下生成/dist/src/img, /dist/src/fonts, 一般我们只需要folder, 只留下目录即可 /dist/img, /dist/fonts.


## 7.webpack中对css的处理
1.提取css到外部文件并压缩html和css  
> npm i  mini-css-extract-plugin optimize-css-assets-webpack-plugin cssnano@4 -D  
```js
const path = require('path')
const webpack = require('webpack')
const HtmlWebpackPlugin = require('html-webpack-plugin')
const { CleanWebpackPlugin } = require('clean-webpack-plugin')
const MiniCssExtractPlugin = require('mini-css-extract-plugin')
const OptimizeCssAssetsWebpackPlugin = require('optimize-css-assets-webpack-plugin')
console.log(process.env.NODE_ENV)
/**
 *  @type {import('webpack').Configuration}
 */
module.exports = {
    watch: false,
    watchOptions: {
        // 类似函数节流防抖, 300ms内无文件改动, webapck才重新编译
        aggregateTimeout: 300,
        ignored: /node_modules/, // 排除node_modules目录
        poll: 10, // 每秒轮训文件是否改动的次数
    },
    entry: {
        index: './src/index.js',
        helloworld: './src/helloworld.js'
    },
    output: {
        path: path.resolve(__dirname, './dist'),
        filename: '[name]-[hash].js'
    },
    module: {
        rules: [
            {
                test: /.js$/,
                use: ['babel-loader']
            },
            {
                test: /.(sc|sa|c)ss$/,
                use: [ 
                    MiniCssExtractPlugin.loader, // 这里使用插件的loader来替代style-loader,将css文件提取出来
                    'css-loader', 
                    'sass-loader'
                ]
            },
            {
                test: /.(woff|woff2|eot|ttf|otf)$/,
                use: ['file-loader']
            },
            {
                test: /.(png|jpg|svg|jpeg)$/,
                use: [
                    {
                        loader: 'url-loader',
                        options: {
                            limit: 1024 * 5, // 4kb以下就压缩成base64格式
                            name: '[folder]/[name]-[hash].[ext]'
                        }
                    }
                ]
            }
        ]
    },
    plugins: [
        // new webpack.HotModuleReplacementPlugin(),
        new CleanWebpackPlugin(),
        new MiniCssExtractPlugin({
            filename: '[name]-[contenthash].css'
        }),
        // 对css进行压缩
        new OptimizeCssAssetsWebpackPlugin({
            assetNameRegExp: /.css/,
            cssProcessor: require('cssnano'),
        }),
        new HtmlWebpackPlugin({
            template: './public/index.html',
            filename: 'index.html',
            chunks: ['index','helloworld'],
            inject: true,
            minify:{
                html5: true,
                collapseWhitespace: true,
                preserveLineBreaks: false,
                minifyCSS: true,
                minifyJS: true,
                removeComments: true,
            }
        }),
    ],
    devServer: {
        contentBase: './dist',
        // hot: true,
        port: 9000,
    },
}

```
2.用postcss对css进行自动添加浏览器前缀和rem
> npm i postcss-loader 
```js
// webpack配置中处理css的rule添加一个postcss-loder
{
    test: /.(sc|sa|c)ss$/,
    use: [ 
        MiniCssExtractPlugin.loader, // 这里使用插件的loader来替代style-loader,将css文件提取出来
        'css-loader', 
        'sass-loader',
        'postcss-loader',
    ]
}
```
根目录下添加一个`postcss.config.js`
```js
//   /postcsss.config.js
module.exports = {
    plugins: [
        require('autoprefixer')({
           overrideBrowserslist: ['last 4 version', '>1%', 'ios 8'] 
        }),
    ]
}
```  

## 8.tree-shaking 
tree-shaking是webapck默认的功能 当打包模式为`production`且模块化为`ES6`模块化时, 会自动tree-shaking, 要求为`ES6`模块的原因可能是在编译时去掉静态模块中未引用的部分, 而commonjs的动态模块则无法判断是否可以tree-shaking掉代码
`通过package.json来控制无需tree-shaking的模块`
```js
{
    "sideEffects": false, // 表示所有代码都没有关联影响, 此时会将 css @/babel/polyfill 等都会被tree-shaking掉
    "sideEffects": ["*.css"] // 表明 *.css文件是有副作用的, 不需要tree-shaking
}
```
## 9.Webpack中对第三方库的处理
1.expose-loader
```js
import $ from 'jquery';
$('body').css('background-color','blue');
```
webpack会把jquery代码打包进bundle, 而且还被webpack的闭包模块包裹, 所以jquery无法在全局使用, 虽然你只需要在你要使用jquery的地方再次引入就好了, 而且不会形成冗余代码, webpack会抽出chunk, 但是还是提供了一个expose-loader暴露到全局的方式
> npm i expose-loader@1 -D
```js
{
    test: require.resolve('jquery'),
    loader: 'expose-loader',
    options: {
        exposes: '$'
    }
}
```
这样在控制台打印$就有全局的$了

2.webpack.ProvidePlugin
```js
    plugins: [
        // ...
        new webpack.ProvidePlugin({
            '$': 'jquery', // 会把node_modules下面的jquery打包进来, 并且全局引入
            'jquery': 'jquery',
        })
    ],
```
```js
// 不用导入jquery都可以全局使用$
$('body').css('background-color','blue');
```

3.code-split
```js
module.exports = {
    optimization: {
        splitChunks: {
            chunks: 'all',  // 会将node_modules里面的包单独打包出一个vendor
        }
    }
}
```

